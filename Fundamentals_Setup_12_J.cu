/*
Compile with the `-v` (verbose) flag to see the internal steps `nvcc` takes, including where it separates host and device code.
The aim of this program is to illustrate the separation between host and device code in a CUDA application. It defines a simple kernel that prints a message from the GPU, and a host function that prints a message from the CPU. By compiling with the `-v` flag, the user can observe the intermediate files generated by the CUDA compiler, such as the PTX file and the host C++ object file, which shows where nvcc splits the program into host and device components. This example uses minimal CUDA API calls and is selfâ€‘contained in a single .cu file, making it easy to compile and run on a system with an NVIDIA GPU and the CUDA toolkit installed.
*/

#include <stdio.h>
#include <cuda_runtime.h>

// Kernel function that runs on the device
__global__ void devicePrint()
{
    // Using printf from device requires enabling device printf capability
    printf("Hello from the device! (GPU thread %d of %d)\n", threadIdx.x, blockDim.x);
}

int main()
{
    // Launch kernel with 1 block of 32 threads
    devicePrint<<<1, 32>>>();

    // Wait for device to finish
    cudaError_t err = cudaDeviceSynchronize();
    if (err != cudaSuccess)
    {
        fprintf(stderr, "CUDA error after kernel launch: %s\n", cudaGetErrorString(err));
        return 1;
    }

    // Host prints its own message
    printf("Hello from the host! (CPU)\n");

    return 0;
}
