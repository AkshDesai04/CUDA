model='gpt-oss:20b' created_at='2025-09-01T06:38:18.226972374Z' done=True done_reason='stop' total_duration=137444742383 load_duration=175816976 prompt_eval_count=258 prompt_eval_duration=399445595 eval_count=1090 eval_duration=29991943131 message=Message(role='assistant', content='# Aim: `Write a function get_gpu_memory_mb(int device_id) that returns the total global memory in MB for the given device.`\n\n""" \nThe task is to provide a CUDA C program that defines a function `get_gpu_memory_mb` which takes a device id as input and returns the total amount of global memory on that device in megabytes (MB). The function should use the CUDA runtime API to query the device properties, specifically `cudaDeviceProp.totalGlobalMem`, and convert the result from bytes to megabytes. Error handling will be included: if the device id is invalid or any CUDA call fails, the function will print an error message and return -1. \n\nThe program will also include a small `main` routine that enumerates all available CUDA devices and prints their total memory using the function. This demonstrates usage and ensures the program compiles and runs on a system with CUDA support.\n\nKey points:\n1. Include necessary headers: `<cuda_runtime.h>` and `<stdio.h>`.\n2. Use `cudaGetDeviceCount` to get the number of devices.\n3. Use `cudaGetDeviceProperties` to retrieve `totalGlobalMem`.\n4. Convert bytes to megabytes by dividing by (1024*1024).\n5. Return an `int`. On error, return -1.\n6. In `main`, iterate over devices, call the function, and display results.\n7. Add error checking for CUDA API calls.\n\nThe resulting code is a selfâ€‘contained, compilable CUDA program that can be saved as a `.cu` file and built with `nvcc`. \n\n"""\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n#include <stdint.h>\n\n/**\n * @brief Returns total global memory of the specified CUDA device in megabytes.\n *\n * @param device_id The CUDA device ID.\n * @return int Total memory in MB on success; -1 on failure.\n */\nint get_gpu_memory_mb(int device_id)\n{\n    cudaError_t err;\n    cudaDeviceProp prop;\n\n    // Check that device ID is non-negative\n    if (device_id < 0) {\n        fprintf(stderr, "Error: Invalid device ID %d. Must be >= 0.\\n", device_id);\n        return -1;\n    }\n\n    // Get device properties\n    err = cudaGetDeviceProperties(&prop, device_id);\n    if (err != cudaSuccess) {\n        fprintf(stderr, "cudaGetDeviceProperties failed for device %d: %s\\n",\n                device_id, cudaGetErrorString(err));\n        return -1;\n    }\n\n    // Convert totalGlobalMem from bytes to megabytes\n    size_t mem_bytes = prop.totalGlobalMem;\n    int mem_mb = (int)(mem_bytes / (1024ULL * 1024ULL));\n    return mem_mb;\n}\n\nint main(void)\n{\n    int device_count = 0;\n    cudaError_t err = cudaGetDeviceCount(&device_count);\n    if (err != cudaSuccess) {\n        fprintf(stderr, "cudaGetDeviceCount failed: %s\\n", cudaGetErrorString(err));\n        return EXIT_FAILURE;\n    }\n\n    if (device_count == 0) {\n        printf("No CUDA-capable devices found.\\n");\n        return EXIT_SUCCESS;\n    }\n\n    printf("Detected %d CUDA device(s):\\n", device_count);\n    for (int i = 0; i < device_count; ++i) {\n        int mem_mb = get_gpu_memory_mb(i);\n        if (mem_mb >= 0) {\n            printf("  Device %d: %d MB of global memory\\n", i, mem_mb);\n        } else {\n            printf("  Device %d: failed to query memory\\n", i);\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n', images=None, tool_calls=None)